{% load i18n %}
{% trans "Close" as toast_close_label %}
<div class="toast-container yamsa-toast-container position-fixed bottom-0 start-50 translate-middle-x px-1 pb-5 mb-5 w-100">
    <div class="toast yamsa-toast border-0 w-100"
         id="toast-id"
         role="alert"
         aria-live="assertive"
         aria-atomic="true">
        <div id="toast-type-div"
             class="toast-yamsa-inner w-100 d-flex align-items-center justify-content-between gap-3 rounded-2 shadow-sm px-4 py-3">
            <span id="toast-message-span"
                  class="flex-grow-1 fw-semibold fs-6 text-truncate"></span>
            <button type="button"
                    class="btn-close btn-close-white"
                    data-bs-dismiss="toast"
                    aria-label="{{ toast_close_label }}"></button>
        </div>
    </div>
</div>
{% if queued_toasts %}
    {{ queued_toasts|json_script:"queued-toasts-data" }}
{% else %}
    <script id="queued-toasts-data" type="application/json">[]</script>
{% endif %}
{% trans "Something went wrong" as something_went_wrong %}
<!-- Toast handler -->
<script type="module">
    const toastElement = document.getElementById("toast-id")
    const toastTypeDiv = document.getElementById("toast-type-div")
    const toastMessageSpan = document.getElementById("toast-message-span")
    const toastBootstrap = bootstrap.Toast.getOrCreateInstance(toastElement)

    const baseToastClasses =
        "toast-yamsa-inner d-flex align-items-center justify-content-between gap-3 rounded-4 shadow-sm px-4 py-3"
    const defaultErrorToastClasses = "{{ toast_classes.error|escapejs }}"
    const defaultErrorMessage = "âš ï¸ {{ something_went_wrong|escapejs }} ðŸ¥º"

    let toastIsVisible = false
    const toastQueue = []

    const applyToastClasses = (classString = "") => {
        toastTypeDiv.className = baseToastClasses
        classString.split(" ").forEach((typeString) => {
            if (typeString.trim()) {
                toastTypeDiv.classList.add(typeString)
            }
        })
    }

    const enqueueToast = (toastDetail) => {

        if (!toastDetail || !toastDetail.message) {
            return
        }

        toastQueue.push(toastDetail)
    }

    const showNextToast = () => {
        if (toastIsVisible || toastQueue.length === 0) {
            return
        }

        const toastDetail = toastQueue.shift()
        toastMessageSpan.innerText = toastDetail.message
        applyToastClasses(toastDetail.type)
        toastBootstrap.show()
    }

    const normalizeToastPayloads = (payload) => {
        if (!payload) {
            return []
        }

        if (Array.isArray(payload)) {
            return payload.reduce((acc, entry) => {
                acc.push(...normalizeToastPayloads(entry))
                return acc
            }, [])
        }

        if (typeof payload === "object") {
            if ("value" in payload && payload.value !== undefined) {
                return normalizeToastPayloads(payload.value)
            }
            if (payload.triggerToast) {
                return normalizeToastPayloads(payload.triggerToast)
            }
            if (payload.message) {
                return [payload]
            }
        }

        return []
    }

    const dispatchQueuedToasts = () => {
        const queuedToastsElement = document.getElementById("queued-toasts-data")
        if (!queuedToastsElement) {
            return
        }

        try {
            const initialToasts = JSON.parse(queuedToastsElement.textContent || "[]")
            if (Array.isArray(initialToasts)) {
                initialToasts.forEach(enqueueToast)
            }
        } catch {
            // swallow parsing errors
        }
    }

    toastElement.addEventListener("shown.bs.toast", () => {
        toastIsVisible = true
    })

    toastElement.addEventListener("hidden.bs.toast", () => {
        toastIsVisible = false
        showNextToast()
    })

    document.body.addEventListener("triggerToast", (evt) => {
        const payloads = normalizeToastPayloads(evt.detail)
        payloads.forEach(enqueueToast)
        showNextToast()
    })

    document.body.addEventListener("htmx:afterRequest", (evt) => {
        if (evt.detail?.successful) {
            return
        }
        enqueueToast({
            message: defaultErrorMessage,
            type: defaultErrorToastClasses,
        })
        showNextToast()
    })

    dispatchQueuedToasts()
    showNextToast()
</script>
